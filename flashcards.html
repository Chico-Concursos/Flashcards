<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chico Concursos - Flashcards com Progresso</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background-color: black;
      color: #FFD700;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #111;
      padding: 10px;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 0px;
    }
    .top-bar button,
    .top-bar select {
      background: none;
      border: none;
      color: white;
      font-size: 1.2em;
      cursor: pointer;
      position: relative;
    }
    .top-bar span {
      font-size: 1.0em;
      color: white;
    }
    .top-bar .timer-icon {
        font-size: 1.0em;
        vertical-align: middle;
    }
    .top-bar select {
      background-color: #222;
      border: 1px solid #555;
      padding: 2px 4px;
    }
    /* Tooltip para bot√µes do topo */
    .tooltip:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 5px 8px;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 0.8em;
      z-index: 10;
    }
    #card-container {
	  position: relative;
      background-color: white;
      color: black;
      width: 96%;
      height: 70vh;
      margin: 1px auto;
      margin-top: 0px;
      padding: 40px 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: auto;
      /* Preserva quebras de linha e espa√ßos do CSV */
      white-space: pre-wrap;
    }
    .bottom-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0px 0;
      flex-wrap: wrap;
      gap: 10px;
    }
    .bottom-bar button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.4em;
      color: white;
      position: relative;
    }
    /* Tooltip para bot√µes da base - aparece e some com JS */
    .bottom-bar button::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 0.75em;
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .bottom-bar button.show-tooltip::after {
      opacity: 1;
    }
    .bottom-bar input[type="number"] {
      width: 50px;
      padding: 2px;
      font-size: 1em;
    }
    #timer {
      cursor: pointer;
    }
    /* Styles for the help modal */
    #helpModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    #helpModalContent {
      background: #222;
      color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
      position: relative;
      max-height: 80vh;
      overflow-y: auto;
      text-align: center;
    }
    #helpModalContent h2 {
      color: gold;
      margin-bottom: 20px;
      font-size: 1.8em;
    }
    #iconLegend p {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      margin-bottom: 10px;
      font-size: 1.1em;
    }
    #iconLegend p span:first-child {
      font-size: 1.5em;
      margin-right: 15px;
      min-width: 40px;
      text-align: center;
    }
    #helpModalContent .close-button {
      background: gold;
      color: black;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 30px;
      font-size: 1.1em;
      transition: background 0.3s ease;
    }
    #helpModalContent .close-button:hover {
      background: #e5c300;
    }
    #fontSizeFeedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: gold;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 1.5em;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.5s ease-out;
        pointer-events: none;
    }
    #shuffleFeedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: gold;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 1.5em;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.5s ease-out;
        pointer-events: none;
    }
    /* Estilo para o display do tempo do temporizador autom√°tico */
    #autoAdvanceTimerDisplay {
      font-size: 1.0em;
      color: white;
      min-width: 40px;
      text-align: center;
    }
    /* Estilos para o modal de configura√ß√£o do temporizador */
    #autoAdvanceSetup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #222;
        color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        z-index: 10001;
        display: none;
        flex-direction: column;
        align-items: center;
    }
    #autoAdvanceSetup h3 {
        margin-bottom: 15px;
        color: gold;
    }
    #autoAdvanceDelayInput {
        padding: 5px;
        font-size: 1em;
        width: 80px;
        text-align: center;
        margin-bottom: 15px;
        background-color: #333;
        color: white;
        border: 1px solid #555;
        border-radius: 4px;
    }
    #autoAdvanceSetup button {
        background-color: #555;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #autoAdvanceSetup button:hover {
        background-color: #777;
    }
    #autoAdvanceSetup button:first-child {
        background-color: gold;
        color: black;
    }
    #autoAdvanceSetup button:first-child:hover {
        background-color: #e5c300;
    }
    #autoAdvanceOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.7);
        z-index: 10000;
        display: none;
    }
    
    /* NOVO: Estilo para o indicador de progresso salvo */
    #cardCounter {
      transition: all 0.5s ease;
      padding: 3px 10px;
      border-radius: 15px;
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    #cardCounter.saved {
      background-color: rgba(0, 128, 0, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }
    
    #cardCounter .current-card {
      color: #32CD32; /* Verde lim√£o que se destaca no preto */
      font-weight: bold;
      transition: color 0.5s ease;
    }
    
    #cardCounter .saved .current-card {
      color: #00FF00; /* Verde mais brilhante quando salvo */
      text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
    }
    
    /* NOVO: Estilos para o modal de estat√≠sticas */
    #statsModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    #statsModalContent {
      background: #222;
      color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
      position: relative;
      max-height: 80vh;
      overflow-y: auto;
      text-align: left;
    }
    
    #statsModalContent h2 {
      color: gold;
      margin-bottom: 20px;
      font-size: 1.8em;
      text-align: center;
    }
    
    .stats-section {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #444;
    }
    
    .stats-section h3 {
      color: #FFD700;
      margin-bottom: 10px;
    }
    
    .card-review-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 5px;
      border-bottom: 1px solid #333;
    }
    
    .card-review-item:nth-child(odd) {
      background-color: rgba(255, 215, 0, 0.1);
    }
    
    .card-review-content {
      flex-grow: 1;
      margin-right: 15px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .card-review-time {
      color: gold;
      font-weight: bold;
      min-width: 70px;
      text-align: right;
    }
    
    /* NOVO: Estilos para a tela de fim */
    #end-screen {
    display: none;
      display: none;
      flex-direction: column;
      justify-content: center; /* Centraliza verticalmente */
      align-items: center; /* Centraliza horizontalmente */
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      z-index: 10;
      text-align: center;
    }
    
    #end-message {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
      color: #FFD700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #FFD700, #D4AF37);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      padding: 20px;
    }
    
    #restart-button {
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      transition: all 0.3s ease;
    }
    
    #restart-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <button class="tooltip" data-tooltip="Cor do cart√£o" onclick="toggleCardColorMenu()">üñåÔ∏è</button>
    <select id="cardColor" onchange="changeCardColor(this.value)" style="display:none;">
     <option value="white">Branco</option>
      <option value="black">Preto</option>
      <option value="darkblue">Azul Escuro</option>
      <option value="aqua">Ciano</option>
      <option value="indigo">√çndigo</option>
      <option value="purple">Roxo</option>
      <option value="darkred">Vermelho Escuro</option>
      <option value="gold">Dourado</option>
    </select>
    <button class="tooltip" data-tooltip="Cor da fonte" onclick="toggleTextColorMenu()">üî§</button>
    <select id="textColor" onchange="changeTextColor(this.value)" style="display:none;">
      <option value="black">Preto</option>
      <option value="white">Branco</option>
      <option value="darkblue">Azul Escuro</option>
      <option value="aqua">Ciano</option>
      <option value="indigo">Indigo</option>
      <option value="purple">Roxo</option>
      <option value="darkred">Vermelho Escuro</option>
      <option value="gold">Dourado</option>
    </select>
    <button class="tooltip" data-tooltip="Aumentar fonte" onclick="adjustFontSize(1)">A+</button>
    <button class="tooltip" data-tooltip="Diminuir fonte" onclick="adjustFontSize(-1)">A-</button>
    <span class="tooltip" data-tooltip="Tempo de revis√£o" onclick="resetTimer()">‚è±Ô∏è <span id="timer">00:00</span></span>
    <!-- NOVO: Bot√£o de estat√≠sticas -->
    <button class="tooltip" data-tooltip="Estat√≠sticas" onclick="toggleStatsModal()">üìà</button>
    <button class="tooltip" data-tooltip="Ajuda" onclick="toggleHelpModal()">‚ùì</button>
  </div>
  <div id="fontSizeFeedback"></div>
  <div id="shuffleFeedback"></div>
  <!-- Elementos para definir o tempo do temporizador -->
  <div id="autoAdvanceSetup">
      <h3>Tempo Autom√°tico (segundos)</h3>
      <input type="number" id="autoAdvanceDelayInput" min="1" value="5" />
      <div>
          <button onclick="confirmAutoAdvanceDelay()">OK</button>
          <button onclick="cancelAutoAdvanceDelay()">Cancelar</button>
      </div>
  </div>
  <div id="autoAdvanceOverlay" onclick="cancelAutoAdvanceDelay()"></div>
  <!-- FIM NOVO -->
  <div id="card-container">
    <div id="flashcard-content">
      Carregando flashcards...
    </div>
    <!-- NOVO: Tela de fim -->
    <div id="end-screen">
      <div id="end-message">Chico Concursos<br>Fim</div>
      <button id="restart-button">RECOME√áAR</button>
    </div>
  </div>
  <div class="bottom-bar">
    <!-- Grupo para o Temporizador Autom√°tico -->
    <div style="display: flex; align-items: center; gap: 5px;">
      <button id="autoAdvanceButton" data-tooltip="Iniciar/Parar Temporizador" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleAutoAdvance()" style="font-size: 1.2em;">‚è≥</button>
      <span id="autoAdvanceTimerDisplay" style="font-size: 1.0em; min-width: 40px;">0s</span>
    </div>
    <!-- FIM NOVO -->
    <input type="number" id="goToCard" min="1" placeholder="1" onchange="goToSpecificCard()" />
    <!-- NOVO: Contador de cards com classe para indicador de progresso -->
    <span id="cardCounter">0/0</span>
    <button data-tooltip="Embaralhar cartas" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleShuffleMode()">üîÄ</button>
    <button data-tooltip="Voltar" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="prevCard()">‚è™</button>
    <button data-tooltip="Resposta/Perg." onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="flipCard()">‚¨áÔ∏è</button>
    <button data-tooltip="Avan√ßar" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="nextCard()">‚è©</button>
    <button id="nextAndShow" data-tooltip="Virar Card / Pr√≥ximo" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="reviewAndAdvance()">‚Ü™Ô∏è</button>
  </div>
  <div id="helpModal" style="display:none;">
    <div id="helpModalContent">
      <h2>Ajuda - Significado dos √çcones</h2>
      <div id="iconLegend">
        <p><span>üñåÔ∏è</span> Cor do cart√£o: Altera a cor de fundo do flashcard.</p>
        <p><span>üî§</span> Cor da fonte: Altera a cor do texto do flashcard.</p>
        <p><span>A+</span> Aumentar fonte: Aumenta o tamanho da letra do flashcard.</p>
        <p><span>A-</span> Diminuir fonte: Diminui o tamanho da letra do flashcard.</p>
        <p><span>‚è±Ô∏è</span> Tempo de revis√£o: Exibe o tempo decorrido e zera ao clicar.</p>
        <p><span>üìà</span> Estat√≠sticas: Mostra seu desempenho e cards para revis√£o.</p>
        <p><span>‚è™</span> Voltar: Navega para o card anterior.</p>
        <p><span>üîÄ</span> Embaralhar cartas: Reorganiza aleatoriamente a ordem dos flashcards.</p>
        <p><span>‚¨áÔ∏è</span> Resposta/Perg.: Vira o flashcard para mostrar a resposta (ou pergunta).</p>
        <p><span>‚è©</span> Avan√ßar: Navega para o pr√≥ximo card.</p>
        <p><span>‚Ü™Ô∏è</span> Virar Card / Pr√≥ximo: Vira o card se na pergunta, avan√ßa se na resposta.</p>
        <p><span>‚è≥</span> Iniciar/Parar Temporizador: Avan√ßa automaticamente para o pr√≥ximo card ap√≥s um tempo definido.</p>
        <p><span>‚èò</span> Barra de Espa√ßo: Vira o card se na pergunta, avan√ßa se na resposta (mesma a√ß√£o do bot√£o ‚Ü™Ô∏è).</p>
        <p><span>üíö</span> Indicador Verde: O n√∫mero em verde mostra que seu progresso foi salvo.</p>
        <p><span>üèÅ</span> Tela Final: Exibida quando todos os flashcards s√£o revisados.</p>
      </div>
      <button class="close-button" onclick="toggleHelpModal()">Fechar</button>
    </div>
  </div>
  
  <!-- NOVO: Modal de estat√≠sticas -->
  <div id="statsModal" style="display:none;">
    <div id="statsModalContent">
      <h2>Estat√≠sticas de Estudo</h2>
      
      <div class="stats-section">
        <h3>√öltimo Acesso</h3>
        <p id="lastAccessDate">Carregando...</p>
      </div>
      
      <div class="stats-section">
        <h3>Cards para Revis√£o</h3>
        <p>Baseado no seu tempo de resposta</p>
        <div id="reviewCardsList"></div>
      </div>
      
      <button class="close-button" onclick="toggleStatsModal()">Fechar</button>
    </div>
  </div>
  
  <script>
    let initialCards = [];
    let cards = [];
    let currentCard = 0;
    let showingFront = true;
    let fontSize = 21.6;
    let timerSeconds = 0;
    const timerElement = document.getElementById("timer");
    const cardContainer = document.getElementById("card-container");
    const cardCounter = document.getElementById("cardCounter");
    const helpModal = document.getElementById("helpModal");
    const fontSizeFeedback = document.getElementById("fontSizeFeedback");
    const shuffleFeedback = document.getElementById("shuffleFeedback");
    let fontSizeDisplayTimeout;
    let shuffleDisplayTimeout;
    let isShuffleActive = false;

    // Vari√°veis para o Temporizador Autom√°tico
    let autoAdvanceInterval = null;
    let autoAdvanceSeconds = 0;
    let autoAdvanceDelay = 5; // Tempo padr√£o em segundos
    let isAutoAdvanceActive = false;
    const autoAdvanceButton = document.getElementById("autoAdvanceButton");
    const autoAdvanceTimerDisplay = document.getElementById("autoAdvanceTimerDisplay");

    // NOVO: Vari√°veis para estat√≠sticas
    let cardResponseTimes = {};
    let lastAccessDate = null;
    let cardShowTime = 0; // Tempo (em ms) quando o card atual foi mostrado
    
    // NOVO: Estado para controlar se chegou ao fim
    let isFinished = false;

    // Fun√ß√£o para obter par√¢metros da URL (sheetId e gid)
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    // Obter sheetId e gid da URL
    const SHEET_ID = getQueryParam('sheetId');
    const GID = getQueryParam('gid') || '0'; // Padr√£o '0' para a primeira aba

    // Fun√ß√£o para construir a URL de fetch usando sheetId e gid
    function buildGoogleSheetCsvUrl(sheetId, gid) {
        if (!sheetId) {
            return null; // Retorna null se sheetId n√£o for fornecido
        }
        // Este √© o formato para exportar diretamente como CSV usando sheetId e gid
        return `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&gid=${gid}`;
    }

    // Parser CSV robusto para lidar com v√≠rgulas e quebras de linha dentro de campos
    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];

            if (char === '"' && !inQuotes) {
                // In√≠cio de um campo entre aspas
                inQuotes = true;
            } else if (char === '"' && nextChar === '"' && inQuotes) {
                // Aspa dupla escapada dentro de um campo entre aspas - Adiciona uma aspa literal
                current += '"';
                i++; // Pula o pr√≥ximo caractere (a segunda aspa)
            } else if (char === '"' && inQuotes) {
                // Fim de um campo entre aspas
                inQuotes = false;
            } else if (char === ',' && !inQuotes) {
                // Separador de campo fora das aspas
                result.push(current.trim());
                current = '';
            } else {
                // Caractere normal
                current += char;
            }
        }
        // Adiciona o √∫ltimo campo
        result.push(current.trim());
        return result;
    }

    // NOVO: Fun√ß√µes para salvar e carregar o estado
    function saveFlashcardState() {
      const state = {
        currentCard,
        showingFront,
        fontSize,
        isShuffleActive,
        deckId: `${SHEET_ID}_${GID}` // Identificador √∫nico do deck
      };
      localStorage.setItem('flashcardState', JSON.stringify(state));
      
      // NOVO: Feedback visual - destacar o contador de cards
      cardCounter.classList.add('saved');
      setTimeout(() => cardCounter.classList.remove('saved'), 1000);
    }

    function loadFlashcardState() {
      const savedState = localStorage.getItem('flashcardState');
      if (!savedState) return false;
      
      try {
        const state = JSON.parse(savedState);
        
        // S√≥ carrega se for o mesmo deck
        if (state.deckId === `${SHEET_ID}_${GID}`) {
          currentCard = state.currentCard >= cards.length ? 0 : state.currentCard;
          showingFront = state.showingFront;
          fontSize = state.fontSize;
          
          // Atualiza o estado do shuffle
          if (state.isShuffleActive !== isShuffleActive) {
            isShuffleActive = state.isShuffleActive;
            if (isShuffleActive) {
              // Re-embaralha mantendo a mesma ordem relativa
              cards = [...cards].sort(() => Math.random() - 0.5);
            } else {
              cards = [...initialCards];
            }
          }
          
          return true;
        }
      } catch (e) {
        console.error("Erro ao carregar estado:", e);
      }
      return false;
    }

    async function loadFlashcardsFromGoogleSheet() {
        const csvUrl = buildGoogleSheetCsvUrl(SHEET_ID, GID);
        if (!csvUrl) {
            document.getElementById("flashcard-content").textContent = "Erro: 'sheetId' n√£o foi fornecido nos par√¢metros da URL. Ex: ?sheetId=SEU_ID_DA_PLANILHA&gid=ID_DA_ABA.";
            console.error("A URL da planilha n√£o p√¥de ser constru√≠da: sheetId ausente.");
            cardCounter.textContent = "0/0";
            return;
        }
        try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
                // Tenta ler o erro do corpo da resposta, se dispon√≠vel
                const errorText = await response.text();
                throw new Error(`Erro HTTP! Status: ${response.status}. Detalhes: ${errorText.substring(0, 200)}...`);
            }
            const text = await response.text();
            // Divide o texto em linhas, lidando melhor com diferentes tipos de quebra de linha
            const lines = text.split(/\r?\n/).slice(1).filter(line => line.trim() !== "");
            let loadedCards = [];

            lines.forEach(line => {
                // Usar o parser robusto para obter as colunas
                const cols = parseCSVLine(line);

                if (cols && cols.length >= 2) {
                    // 1. Extrair o texto bruto das colunas A e B
                    let rawFrontText = cols[0];
                    let rawBackText = cols[1];

                    // 2. Limpar espa√ßos em branco extras no in√≠cio/fim
                    let frontText = (rawFrontText || '').trim();
                    let backText = (rawBackText || '').trim();

                    // 3. Substituir aspas duplas (") por asteriscos (*)
                    frontText = frontText.replace(/"/g, '*');
                    backText = backText.replace(/"/g, '*');

                    // 4. Adicionar ao array de cards
                    loadedCards.push({ front: frontText, back: backText });
                } else {
                     //console.warn("Linha CSV inv√°lida ou incompleta ignorada:", line);
                     //console.log("Cols extra√≠das:", cols);
                }
            });

            if (loadedCards.length === 0) {
                document.getElementById("flashcard-content").textContent = "Nenhum flashcard encontrado na planilha. Verifique os dados ou se as colunas est√£o corretas.";
                console.warn("Nenhum card carregado da planilha.");
                cardCounter.textContent = "0/0";
            } else {
                initialCards = loadedCards;
                cards = [...initialCards];
                
                // NOVO: Tenta carregar estado salvo
                const hasSavedState = loadFlashcardState();
                
                // Se n√£o encontrou estado salvo v√°lido, inicia do zero
                if (!hasSavedState) {
                  currentCard = 0;
                  showingFront = true;
                }
                
                // NOVO: Carregar estat√≠sticas
                loadStatsFromStorage();
                // Atualizar data do √∫ltimo acesso
                lastAccessDate = new Date();
                saveStatsToStorage();
                
                updateCard();
            }
        } catch (error) {
            console.error("Erro ao carregar os flashcards da planilha:", error);
            document.getElementById("flashcard-content").textContent = `Erro ao carregar flashcards: ${error.message}. Verifique sheetId, gid ou permiss√µes da planilha.`;
            cardCounter.textContent = "0/0";
        }
    }

    function updateCard() {
      if (cards.length === 0 || isFinished) {
        return;
      }
      
      const card = cards[currentCard];
      document.getElementById("flashcard-content").textContent = showingFront ? card.front : card.back;
      
      // NOVO: Atualiza o contador com formata√ß√£o especial
      cardCounter.innerHTML = `<span class="current-card">${currentCard + 1}</span>/<span>${cards.length}</span>`;
      
      document.getElementById("flashcard-content").style.fontSize = fontSize + "pt";

      // Reinicia o temporizador autom√°tico ao mudar de card
      if (isAutoAdvanceActive) {
        autoAdvanceSeconds = autoAdvanceDelay;
        updateAutoAdvanceDisplay();
      }
      
      // NOVO: Registrar o momento em que o card foi mostrado
      cardShowTime = performance.now();
    }

    function nextCard() {
      if (isFinished) return;
      
      if (currentCard === cards.length - 1) {
        // NOVO: Chegou ao √∫ltimo card - mostrar tela de fim
        showEndScreen();
        saveFlashcardState();
        return;
      }
      
      currentCard = (currentCard + 1) % cards.length;
      showingFront = true;
      updateCard();
      // NOVO: Salvar o estado
      saveFlashcardState();
    }

    function prevCard() {
      if (isFinished) return;
      
      currentCard = (currentCard - 1 + cards.length) % cards.length;
      showingFront = true;
      updateCard();
      // NOVO: Salvar o estado
      saveFlashcardState();
    }

    function flipCard() {
      if (isFinished) return;
      
      // Calcular tempo gasto antes de virar
      if (showingFront) {
        const timeSpent = Math.round((performance.now() - cardShowTime) / 1000);
        recordResponseTime(currentCard, timeSpent);
      }
      
      showingFront = !showingFront;
      updateCard();
      saveFlashcardState();
    }

    function reviewAndAdvance() {
      if (isFinished) return;
      
      // Calcular tempo gasto antes de virar se estiver na frente
      if (showingFront) {
        const timeSpent = Math.round((performance.now() - cardShowTime) / 1000);
        recordResponseTime(currentCard, timeSpent);
      }
      
      if (showingFront) {
        showingFront = false;
        updateCard();
      } else {
        nextCard();
      }
      saveFlashcardState();
    }

    function toggleShuffleMode() {
      if (isFinished) return;
      
      if (!isShuffleActive) {
        for (let i = cards.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [cards[i], cards[j]] = [cards[j], cards[i]];
        }
        isShuffleActive = true;
        shuffleFeedback.textContent = "Modo embaralhar ativado!";
      } else {
        cards = [...initialCards];
        isShuffleActive = false;
        shuffleFeedback.textContent = "Ordem original restaurada!";
      }
      currentCard = 0;
      showingFront = true;
      updateCard();
      shuffleFeedback.style.opacity = 1;
      clearTimeout(shuffleDisplayTimeout);
      shuffleDisplayTimeout = setTimeout(() => {
        shuffleFeedback.style.opacity = 0;
      }, 1500);
      saveFlashcardState();
    }

    function adjustFontSize(change) {
      fontSize += change * 1.2;
      fontSize = Math.max(10, Math.min(48, fontSize));
      document.getElementById("flashcard-content").style.fontSize = fontSize + "pt";
      fontSizeFeedback.textContent = `${fontSize.toFixed(1)}pt`;
      fontSizeFeedback.style.opacity = 1;
      clearTimeout(fontSizeDisplayTimeout);
      fontSizeDisplayTimeout = setTimeout(() => {
        fontSizeFeedback.style.opacity = 0;
      }, 1500);
      saveFlashcardState();
    }

    function toggleCardColorMenu() {
      const menu = document.getElementById("cardColor");
      menu.style.display = menu.style.display === "none" ? "inline-block" : "none";
    }

    function toggleTextColorMenu() {
      const menu = document.getElementById("textColor");
      menu.style.display = menu.style.display === "none" ? "inline-block" : "none";
    }

    function changeCardColor(color) {
      cardContainer.style.backgroundColor = color;
      saveFlashcardState();
    }

    function changeTextColor(color) {
      document.getElementById("flashcard-content").style.color = color;
      saveFlashcardState();
    }

    function resetTimer() {
      timerSeconds = 0;
      timerElement.textContent = "00:00";
    }

    function updateTimer() {
      timerSeconds++;
      const minutes = String(Math.floor(timerSeconds / 60)).padStart(2, '0');
      const seconds = String(timerSeconds % 60).padStart(2, '0');
      timerElement.textContent = `${minutes}:${seconds}`;
    }
    setInterval(updateTimer, 1000);

    function goToSpecificCard() {
      if (isFinished) return;
      
      const value = document.getElementById("goToCard").value;
      const number = parseInt(value, 10);
      if (!isNaN(number) && number >= 1 && number <= cards.length) {
        currentCard = number - 1;
        showingFront = true;
        updateCard();
        saveFlashcardState();
      } else {
        alert("N√∫mero do card inv√°lido. Insira um n√∫mero entre 1 e " + cards.length);
      }
      document.getElementById("goToCard").value = '';
    }

    function showTooltipOnHover(el) {
      clearTimeout(el.tooltipTimer);
      el.classList.add("show-tooltip");
      el.tooltipTimer = setTimeout(() => {
        el.classList.remove("show-tooltip");
      }, 1000);
    }

    function hideTooltipOnLeave(el) {
      clearTimeout(el.tooltipTimer);
      el.classList.remove("show-tooltip");
    }

    function toggleHelpModal() {
      if (helpModal.style.display === "none") {
        helpModal.style.display = "flex";
      } else {
        helpModal.style.display = "none";
      }
    }

    // Fun√ß√µes para o Temporizador Autom√°tico
    function toggleAutoAdvance() {
      if (isAutoAdvanceActive) {
        stopAutoAdvance();
      } else {
        startAutoAdvance();
      }
    }

    // FUN√á√ÉO MODIFICADA PARA USAR O MODAL CUSTOMIZADO
    function startAutoAdvance() {
        if (isAutoAdvanceActive) return; // Evita m√∫ltiplas inicializa√ß√µes

        // Mostra o elemento de configura√ß√£o em vez de usar prompt()
        document.getElementById("autoAdvanceDelayInput").value = autoAdvanceDelay; // Preenche com o valor atual
        document.getElementById("autoAdvanceSetup").style.display = "flex";
        document.getElementById("autoAdvanceOverlay").style.display = "block";
    }
    // FIM MODIFICA√á√ÉO

    // Fun√ß√µes para lidar com a entrada de tempo customizada
    function confirmAutoAdvanceDelay() {
        const userInput = document.getElementById("autoAdvanceDelayInput").value;
        const newDelay = parseInt(userInput, 10);

        // Esconde o elemento de configura√ß√£o
        document.getElementById("autoAdvanceSetup").style.display = "none";
        document.getElementById("autoAdvanceOverlay").style.display = "none";

        if (isNaN(newDelay) || newDelay <= 0) {
            // Feedback visual inline ao inv√©s de alert
            const feedback = document.createElement('div');
            feedback.textContent = "N√∫mero inv√°lido!";
            feedback.style.position = 'fixed';
            feedback.style.top = '50%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            feedback.style.color = 'white';
            feedback.style.padding = '10px 15px';
            feedback.style.borderRadius = '8px';
            feedback.style.zIndex = '10002';
            feedback.style.pointerEvents = 'none';
            document.body.appendChild(feedback);
            setTimeout(() => document.body.removeChild(feedback), 2000);
            return;
        }
        autoAdvanceDelay = newDelay;

        // Inicia o temporizador com o valor confirmado
        isAutoAdvanceActive = true;
        autoAdvanceSeconds = autoAdvanceDelay; // Reinicia o contador visual
        updateAutoAdvanceDisplay(); // Mostra o tempo inicial

        // Muda o √≠cone do bot√£o para indicar atividade
        if (autoAdvanceButton) {
            autoAdvanceButton.textContent = "‚è∞"; // Rel√≥gio como indicador de atividade
        }

        autoAdvanceInterval = setInterval(() => {
            autoAdvanceSeconds--;
            updateAutoAdvanceDisplay();

            if (autoAdvanceSeconds <= 0) {
                // Usa reviewAndAdvance para virar ou avan√ßar
                reviewAndAdvance();
                autoAdvanceSeconds = autoAdvanceDelay; // Reinicia o contador
                updateAutoAdvanceDisplay(); // Atualiza o display ap√≥s a a√ß√£o
            }
        }, 1000);
    }

    function cancelAutoAdvanceDelay() {
        // Esconde o elemento de configura√ß√£o
        document.getElementById("autoAdvanceSetup").style.display = "none";
        document.getElementById("autoAdvanceOverlay").style.display = "none";
        // N√£o faz mais nada, o usu√°rio cancelou
    }

    function stopAutoAdvance() {
        if (!isAutoAdvanceActive) return;

        clearInterval(autoAdvanceInterval);
        autoAdvanceInterval = null;
        isAutoAdvanceActive = false;
        autoAdvanceSeconds = 0; // Zera o contador visual
        updateAutoAdvanceDisplay(); // Atualiza o display para 0s

        // Restaura o √≠cone do bot√£o
        if (autoAdvanceButton) {
             autoAdvanceButton.textContent = "‚è≥"; // Ampulheta para indicar parado
        }
    }

    function updateAutoAdvanceDisplay() {
        if (autoAdvanceTimerDisplay) {
            autoAdvanceTimerDisplay.textContent = `${autoAdvanceSeconds}s`;
        }
    }
    
    // NOVO: Fun√ß√£o para registrar tempo de resposta
    function recordResponseTime(cardIndex, timeSpent) {
      if (!cardResponseTimes[cardIndex]) {
        cardResponseTimes[cardIndex] = {
          times: [],
          avgTime: 0
        };
      }
      
      cardResponseTimes[cardIndex].times.push(timeSpent);
      
      // Calcular nova m√©dia
      const times = cardResponseTimes[cardIndex].times;
      const sum = times.reduce((a, b) => a + b, 0);
      cardResponseTimes[cardIndex].avgTime = Math.round(sum / times.length);
      
      // Atualizar armazenamento
      saveStatsToStorage();
    }
    
    // NOVO: Fun√ß√£o para salvar estat√≠sticas
    function saveStatsToStorage() {
      const stats = {
        responseTimes: cardResponseTimes,
        lastAccess: new Date().toISOString()
      };
      
      localStorage.setItem(`flashcardStats_${SHEET_ID}_${GID}`, JSON.stringify(stats));
    }
    
    // NOVO: Fun√ß√£o para carregar estat√≠sticas
    function loadStatsFromStorage() {
      const savedStats = localStorage.getItem(`flashcardStats_${SHEET_ID}_${GID}`);
      if (!savedStats) return;
      
      try {
        const stats = JSON.parse(savedStats);
        cardResponseTimes = stats.responseTimes || {};
        
        if (stats.lastAccess) {
          lastAccessDate = new Date(stats.lastAccess);
        }
      } catch (e) {
        console.error("Erro ao carregar estat√≠sticas:", e);
      }
    }
    
    // NOVO: Fun√ß√£o para abrir/fechar modal de estat√≠sticas
    function toggleStatsModal() {
      const modal = document.getElementById("statsModal");
      if (modal.style.display === "none") {
        modal.style.display = "flex";
        updateStatsModal();
      } else {
        modal.style.display = "none";
      }
    }
    
    // NOVO: Fun√ß√£o para atualizar conte√∫do do modal de estat√≠sticas
    function updateStatsModal() {
      // Atualizar data do √∫ltimo acesso
      const lastAccessElement = document.getElementById("lastAccessDate");
      if (lastAccessDate) {
        lastAccessElement.textContent = lastAccessDate.toLocaleString();
      } else {
        lastAccessElement.textContent = "Nenhum registro encontrado";
      }
      
      // Gerar lista de cards para revis√£o
      const reviewList = document.getElementById("reviewCardsList");
      reviewList.innerHTML = "";
      
      // Criar array de cards com tempo m√©dio
      const cardsWithTimes = [];
      for (const [index, data] of Object.entries(cardResponseTimes)) {
        cardsWithTimes.push({
          index: parseInt(index),
          avgTime: data.avgTime,
          content: initialCards[index].front // Usar a frente do card como conte√∫do
        });
      }
      
      // Ordenar por tempo m√©dio (maiores primeiro)
      cardsWithTimes.sort((a, b) => b.avgTime - a.avgTime);
      
      // Mostrar os top 5
      const topCards = cardsWithTimes.slice(0, 5);
      
      if (topCards.length === 0) {
        reviewList.innerHTML = "<p>Nenhum dado de estudo dispon√≠vel ainda.</p>";
        return;
      }
      
      topCards.forEach(card => {
        const item = document.createElement("div");
        item.className = "card-review-item";
        
        const content = document.createElement("div");
        content.className = "card-review-content";
        content.textContent = card.content.length > 60 
          ? card.content.substring(0, 60) + "..." 
          : card.content;
          
        const time = document.createElement("div");
        time.className = "card-review-time";
        time.textContent = `${card.avgTime}s`;
        
        item.appendChild(content);
        item.appendChild(time);
        reviewList.appendChild(item);
      });
    }
    
    // NOVO: Fun√ß√£o para mostrar a tela de fim
    function showEndScreen() {
      document.getElementById('flashcard-content').style.display = 'none';
      document.getElementById('end-screen').style.display = 'flex';
      isFinished = true;
    }
    
    // NOVO: Fun√ß√£o para recome√ßar os flashcards
    function restartFlashcards() {
      document.getElementById('end-screen').style.display = 'none';
      document.getElementById('flashcard-content').style.display = 'block';
      currentCard = 0;
      showingFront = true;
      isFinished = false;
      updateCard();
      saveFlashcardState();
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === " " || e.key === "Enter") {
        e.preventDefault();
        reviewAndAdvance();
      }
    });

    // Chama a fun√ß√£o para carregar os cards da planilha usando SHEET_ID e GID
    loadFlashcardsFromGoogleSheet();
    
    // Salvar estado quando a p√°gina for fechada
    window.addEventListener('beforeunload', saveFlashcardState);
    
    // NOVO: Adicionar evento ao bot√£o de recome√ßar
    document.getElementById('restart-button').addEventListener('click', restartFlashcards);
  </script>
</body>
</html>
